\input texinfo   @c -*-texinfo-*-
@setfilename OpenIPMI.info
@settitle OpenIPMI Interface Users's Guide
@setchapternewpage odd

@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{OpenIPMI User's Guide}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002,2003 MontaVista Software
@end titlepage

@node    Top,       Intro to IPMI,         , (dir)

This document describes OpenIPMI, and IPMI abstraction layer that makes
IPMI easier to use, and allows OEM vendors to supply plugins to support
their special sensors and controls.

@menu
* Intro to IPMI::     A little about IPMI
* Concept Index::     
* OpenIPMI Concepts::
* Using OpenIPMI::
* How to Write OEM Plugins::
* Internals::
* Debugging Your Application::
* The IPMI LAN Server::
* Glossary::
* OEM Specific Information::
@end menu

@node    Intro to IPMI, OpenIPMI Concepts, Top,      Top
@comment node-name,     next,          previous, up
@chapter Intro to IPMI
@cindex intro

If you have read the IPMI spec, you are probably thoroughly confused
about IPMI.  The IPMI spec doesn't provide the high-level expected usage
of IPMI.  This chapter covers that information.  It provides a
high-level view of how IPMI is expected to be used.

@menu
* Things in IPMI::
* How IPMI Works::
* The User View::
@end menu

@node    Things in IPMI, How IPMI Works, Intro to IPMI, Intro to IPMI
@section Things in IPMI

IPMI is a specification for system monitoring.  It monitors entities in
your system with sensors.  Sensors can generate events such as state
changes or out of range conditions which may be stored in a System Event
Log (SEL) and forwarded to listening parties.  Information about the
system may be stored in Sensor Data Records (SDRs), which hold
information about a whole lot more things than sensors.  Various
Management Controllers (MCs) may exist in the system, these are the
intelligent devices that handle the sensors in the system.  The main MC
is the Baseboard Management Controller (BMC), it is what what the
external software interacts with directly, through a system
interface, a LAN connection, a serial connection, etc.  Messages to
other MCs in the system go through the BMC.

Note that a sensor may be something you don't traditionally think of as
a sensor.  Beyond standard analog sensors, there are sensors for the
presence of entities, sensors for buttons, sensors for predictive
failures, and a host of other things.  An MC may generate events as the
BIOS on the board it's on goes through it's processing.  In general, a
sensor may be attached to anything that can be sensed or monitored.

Inside the system, the various devices generally communicate over an
Intelligent Peripheral Management Bus (IPMB).  So if you need to message
a specific sensor, you will send a message to the BMC asking it to
forward the message to the proper MC over the IPMB bus.  The destination
is specified via an IPMB address.

IPMB addresses contain a slave address, which identifies the MC.  They also
contain a Logical Unit Number (LUN), which identifies an entity inside
the MC.

Some types of connections need to be authenticated, you will need to
provide userids and passwords for the BMC to accept your messages.
Several different authentication algorithms are available.

Authentication is done on LAN connections (and in the future, on dial-in
connections).  There is no authentication on SMI connections.  There are
four standard mechanisms for authentication.  The session is established
using the userid/key, and once the session is up, the key must be
present in every packet if authentication is done.  The methods of
authentication are:

@enumerate
@item none - No authentication is done
@item straight - The password is transmitted in plain text over the
network as part of the packet.  The host and target will not accept a
packet without the right key.
@item md2 - The ``Message Digest Algorithm 2'' is applied to the contents
of the packet using the password, and an authentication code is
generated.  The host and target will not accept a message who's
authentication codes do not match.  The password is *not* transmitted
over the network and it is difficult to find the password or generate
valid packets by just looking at the data and authentication code.
@item md5 - Like md2, but uses the ``Message Digest Algorithm 5''.
@end enumerate

The use of md5 or md2 is strongly recommended.

@node    How IPMI Works, The User View, Things in IPMI, Intro to IPMI
@section Things in IPMI

So now we've got a BMC, MCs, and things like that.  But how are you
expected to use raw IPMI?

The first things you must do, of course, it connect to the BMC.  If it's
a direct SMI connection (A SMIC, KCS, or BT interface, or perhaps a
non-standard serial interface), you just open the driver on the
operating system and start messaging.  If it's a LAN-type connection,
you have to go through an authentication sequence.  One you have a
connection to the BMC, things are pretty much the same no matter what
interface you have.  There are a few messaging for doing special
controls on a LAN interface, but they don't generally matter to the
user.

Once the connection to the BMC is up, the user should query to see what
channels the BMC supports.  For 1.5 and later, it gets this from a
command.  For 1.0, it gets it from the main SDR repository.

Once you are connected, you should scan the SDRs in the main SDR
repository for any entities and sensors.  Sensors and entities may
also be in the device SDR repository, which should be scanned next.
This allows the user to discover the sensors in the system.  Note that
the sensors may point to entities that don't have a entry in the SDR
that defines them, those entities need to be handled when they are
detected.

After this point in time, the interface could be deemed to be ``up''.
However, there's still more to do.

If the interface supports an event queue, the user will have to poll it
(if the driver doesn't deliver them asynchronously, that is).  If the
interface doesn't support an event queue the user should periodically
scan the system event log for new events.  (Note that even if it does
support an event queue, the user should still poll the system event log
in case the event queue missed any events coming in.)

Also, the user should start scanning the IPMB bus with broadcast get
device id commands to detect any MCs on the bus.

This is what OpenIPMI does for you.  Beyond this, it also represents the
sensors, controls, and entities in a nice OO fashion, and it handles the
details of addressing, message routing, and other things you don't
really care about.  It lets you get right at the sensors and entities.

@node    The User View, , How IPMI Works, Intro to IPMI
@section The User View

A bunch of acronyms have just been introduced, along with a lot of
vague concepts, and some description about how to use IPMI.  The nice
thing is that the user of OpenIPMI doesn't really have to know about
all these things.  From the user's point of view, the entity provides
the central framework for everything sensors and controls.  Sensors
monitor entities.  Entities may be present or absent.  When you
connect to an interface, OpenIPMI takes care of detecting the entities
in the system and reporting them to you.  You may register to be told
when entities are added or removed from the database.  Note that an
entity may be present in the database, but not present in the system,
the reporting from only gives the presence in the database, not
physical presence in the system.

The user must know about two other OpenIPMI concepts: connections and
domains.  A connection provides the interface to the IPMI system.  In
essence, it is the BMC connection.  You must allocate one or more
connections and create a domain with them.  OpenIPMI supports multple
connections to a domain in some cases, but currently it requires the OEM
plugins exist.  A domain represents a set of devices on a bus (like
IPMB) whose entities will be unique.  For instance, a chassis with a lot
of cards plugged could be a domain, each card could be an entity and
then create it's own sub-entities, but they will be designed so the
entity id's don't collide.

OpenIPMI will automatically manage the connections, activating and
deactating the proper connections (if the connections support that),
detecting failures and switching over, etc.

Though the user doesn't have know the inner details of IPMI addressing
and messaging, they do need to know about entities and sensors.
OpenIPMI mainly focuses on representing the entities and sensors in
convenient ways.  The user still needs to understand the capabilities of
sensors, how the sensors advertise those capabilties, and the things
that can be done to the sensors.

You may register with an entity to be told when it's physical presence
in the system changes.  Some devices (like power supplies) are
field-replacable while the system is running, these are called Field
Replacable Units (FRUs).  They may have sensors that monitor them, but
those sensors may not be active if the device is not physically present
in the system.

Sensors are also automatically detected and reported.  This is done
through entities, you register with an entity to be told when a sensor
has been added or removed.  IPMI defines special types of sensors called
Presence Sensors, these report if an entity is present in the system.  A
presence sensor is @emph{not} reported to the user, OpenIPMI attaches
these to the entity directly and uses them to detect the presence of the
entity.

Sensors provide a lot of functions depending on their type.  Threshold
sensors monitor ``analog'' things like temperature, voltage, or fan speed.
Discrete sensors monitor events or states, like the previously
introduced presence sensor, software initialization progress, or if
external power is present to the system.

Threshold sensors report their readings in values from 0-255.  OpenIPMI
makes every effort to convert this to a floating-point value for you to
use.  IPMI defines standard ways to convert values using various
formulas.  OpenIPMI implements all these and provides ways for OEM
functions to plug in to provide their own converters.  If you have a
sensor that cannot be represented using the standard mechanisms, you
need to get the OEM algorithms for this and implement them in an OEM
plug-in for the sensors.

You may enable events on a threshold sensor by specifying values (called
thresholds) where you want the sensor to report an event.  Then you can
enable the events for the specific thresholds.  Not all sensors support
all thresholds, some cannot have their events enabled and others cannot
have them disabled.  The capabilities of a sensor may all be queried
by the user to determine what it can do.

Threshold sensors may have hysteresis, meaning that when the threshold
goes on above or below the specified value, the transition point where
the threshold goes off is somewhat below or above the given value.  For
instance, if you want a fan speed sensor to go off when it goes below
150 RPM, if the fan is hanging right around 150 RPM, the sensor may be
constantly sending you events as it goes slightly above and slightly
below 150 RPM, which is bad because it can overload the system
management software.  The hysteresis for the fan might be set at 10 rpm,
which means that if the speed goes below 150 RPM, then it must go above
160 RPM for the threshold to be disabled.  Hysteresis may be settable or
may be fixed for the sensor.

Discrete sensors report their readings in a 16-bit bitmask, each bit
representing a dicrete value.  You enable events on the sensor by
specifying which discrete values you want to generate events.  Like
threshold sensors, these events may or may not be user-controllable.
That information may be fetched by the user.

@c **********************************************************************
@node    OpenIPMI Concepts, Using OpenIPMI,  Intro to IPMI, Top
@chapter OpenIPMI Concepts

OpenIPMI is an event-driven library that is designed to be relatively
operating system independent.  If you have written control systems or
things like that in the past, you will be quite familiar with
event-driven systems and may skip to the next section.  If not, you want
to read this.  Event-driven systems may seem a little unusual, but they
are accepted practice and by far the best way to build control systems.

@menu
* Event-Driven Systems::
* The OS Handler::
* Messaging Interfaces::
* Error Handling::
* Locking::
* OpenIPMI Objects::
* Callbacks::
@end menu

@node    Event-Driven Systems, The OS Handler, OpenIPMI Concepts, OpenIPMI Concepts
@section Event-Driven Systems

In an event-driven system, you never stop and wait for something to
happen.  If you are not used to this, you are probably used to writing
code like this:
@example
  while (true) @{
    wait_for_input();
    perform_op1();
    wait_for_op1_results();
    perform_op2();
  @}
@end example
This is fairly straightforward, but it has some problems.  What if
another more important input comes in while you are waiting for the
results of @code{perform_op1()}?  Now @code{wait_for_op1_results()} will
have to handle input, too, and somehow return and say something is
happening.  The loop will then have to somehow handle multiple
operations in progress.  And this is a simple example, what if there
were hundreds of possible inputs, each with their own result handler,
and each had to go through several states?  You could assign each to a
thread, but if you have thousands of possible pending operations in a
system, that many threads may thrash your system and render it
inoperable, probably right at the time you need it most (since a lot of
things are going on).

In an event-driven system, instead you would say:
@example
  init()
  @{
    <initialize input_data>
    register_for_input(op1_handler, input_data);
  @}
  op1_handler(input_data)
  @{
    <allocate and initialize op_data>
    perform_op1(..., op2_handler, op_data);
  @}
  op2_handler(op_data)
  @{
    perform_op2();
    <free op_data>
  @}
@end example
As you see, when you start an operation, you provide the next thing to
call when the operation completes.  The functions passed around are
called ``callbacks''.  You allocate and pass around chunks
of data to be passed to the handlers.  And you register input handler
that get called when certain event occur.  So the code runs in short
non-blocking sections, registers for the next operation, then returns
back to some invisible main loop that handles the details of scheduling
operations.  This may seem more complicated than the previous example,
but it has a large number of advantages:
@enumerate
@item The system is almost always ready to handle input.  For instance,
user-interface systems (like most widget sets) are almost always
event-driven, this
makes them much more ``live'', since they are always ready to handle
user input.
@item This system can handle multiple operations simultaneously without
threads.  In general, threaded systems are less reliable and more
complicated, unless you need priorities or scalability on SMP, why use
them?  And even if you use them, you can have much better control over
what is running in the system.
@item If you are building a redundant system with data replication, this
gives you a natural way to hold your data, know when to transfer it over
to the mate system, and continue an operation on the mate system.
@item If you track the data, it's easy to monitor every operation
occuring in the system, stop an operations, or whatever.
@item It's much easier to detect and manage overload situations in an
event driven system.  Event-driven systems have event queues of things
waiting to be processed.  You can put things in the queue and watch the
queue length.  If the queue length gets too big, you are in overload,
and can intelligently decide which events you want to throw away, based
on priority, time to live, or some other criteria.
@end enumerate

In general, a threaded system is easier to conceptually understand until
you understand event-driven methods.  An event-driven system is almost
always easier to correctly implement.

Note that event-driven systems don't preclude the use of threads.
Threads may be vastly overused, but they are important.  You could, for
example, allocate one event loop thead per CPU to help scale your
system.  You need to use threads to manage priorities.  Some inputs may
be more important than others, so you may have an event loop for each
priority and feed them that way.  You have a thread per CPU, and/or a
thread per priority, but you don't need a thread per operation.

This is often called ``state-machine programming'' since most control
systems are state-machine based, and this is a natural way to implement
a state machine.  The @code{op_data} holds the state of the state
machine, each input gets @code{op_data}, looks at the current state, and
decides what to do next.

The OpenIPMI library is completely event-driven.  It has no internal
blocking operations, and it expects that anything it calls will not
block.  IPMI messaging and operating system primitives are provided
through external plug-in pieces.

If a library function that takes a callback does not return an error,
the callback is guaranteed to be called, even if the object the call is
associated with goes away.  If it goes away, a NULL may be passed in as
the object to the callback, but the @code{cb_data} will still be valid.

@node    The OS Handler, Messaging Interfaces, Event-Driven Systems, OpenIPMI Concepts
@section The OS Handler

The OS handler provides services for the OpenIPMI library.  These
services are:
@table @samp
@item Input Callbacks
The OpenIPMI code uses the ``file descriptor'' concept of *nix, input
devices are numbered.  This is not used internally in the library, but
it is used by the messaging interfaces, so the messaging interfaces and
OS handler may implement their own conventions for these numbers.  This
provides a way for OpenIPMI to register to receive input from devices.

@item Timers
OpenIPMI times everthing (as it should), thus it needs timers.

@item Locks
OpenIPMI does not require locks, you may leave the operations NULL and
they won't be used.  However, if you are doing multi-threaded
operations, you should provide locks.  The locks should be recursive
(the same lock may be claimed multiple times by the same thread).  You
need to provide read/write locks operations, although these may be
normal locks (the system will just be less responsive).

@item Condition Variables
These are condition variables like the ones specified in POSIX threads.
Although OpenIPMI does not use condition variables (since it never waits
for anything) it may be convenient for other things to have them.
OpenIPMI does not use them, and if nothing in your system needs them,
they need not be provided.

@item Random Data
For certain operations, OpenIPMI needs random data.
@end table

@node    Messaging Interfaces, Error Handling, The OS Handler, OpenIPMI Concepts
@section Messaging Interfaces

Messaging interfaces provide the low-level interface to the BMC.  It can
be through a LAN, a system interface, a serial port, or a host of other
possible interfaces.

@node    Error Handling, Locking, Messaging Interfaces, OpenIPMI Concepts
@section Error Handling

Almost all OpenIPMI calls that do anything besides fetch a piece of
local data will return an integer error value.  A zero means no error.
Two types of errors are returned, system errors (which are standard Unix
errno values) and IPMI errors (which are the standard IPMI error codes).
You can use the macros @var{IPMI_IS_OS_ERR} and
@var{IPMI_IS_IPMI_ERR} to tell the type of error, and
@var{IPMI_GET_OS_ERR} and @var{IPMI_GET_IPMI_ERR} to get
the actual error values.

Note that if your system doesn't have Unix-type error numbers, you will
have to provide those for the OpenIPMI library.

If a function returns an error, any callbacks provided to that function
will @emph{never} be called.  If a function that takes a callback
returns success, the callback will @emph{always} be called, even if the
object associated has ceased to exist.  If an object with outstandard
operations ceases to exist, all the callbacks for outstanding operations
will be called with ECANCELED as the error.  Errors are passed into many
callbacks, if an error is present the rest of the data in the callback
is probably not valid except for the @code{cb_data} variable you
provide, and possibly the object the callback is associated with.  The
object the callback is associated with may be NULL if it has ceased to
exist.

@node    Locking, OpenIPMI Objects, Error Handling, OpenIPMI Concepts
@section Locking

As mentioned before, you may or may not be using locking, @strong{but
you must read this section anyway.}  Locking here involves existance of
entities as well as normal locking.

The basic principle of locking is that if you are in a callback for an
IPMI object (an IPMI object is passed in the callback), that object is
locked and the system cannot change it.  In any callback for an object
owned by a particular domain, that object will be locked and anything it
belongs to will be locked.  So, for instance, in a callback for a
sensor, the sensor is locked, the entity the sensor belongs to is
locked, the management controller the sensor is on is locked, and the
domain the sensor is in will be locked.  No other sensors, entities, or
management controllers will necessarily be locked.  Outside of
callbacks, the library is free to change pointers, change information,
add and remove objects, or whatever it wants.

So how do you obtain a lock for an IPMI object?  If you are handling
incoming IPMI events you generally don't have to worry about this.  But
say you are handling outside input, such as a user interface.  What
then?  If the pointers can change, how do I keep a reference to
something?

OpenIPMI provides two identifiers for IPMI objects.  One is a pointer,
but a pointer is only good inside a callback.  The other is an OpenIPMI
id, the id is good outside callbacks.  But the only thing you can do with
an id is pass it to a function that will call a callback for you with
the pointer.  You can convert a pointer to an id (inside a callback, of
course) so you should do that if you need to save a reference to the
object.

This mechanism, though a little inconvenient, almost guarantees that you
will not forget to release a lock.  It nicely encapsulates the locked
operation in a function@footnote{This is how locking works in Ada95 and
Java, although their mechanisms are a little more convenient since they
are built into the language}.  You have to return from the function
unless you exit, longjmp, or throw an exception that falls through the
callback, and you shouldn't do those things.

You must do this whether you are using locking or not, because the
library uses this mechanism to determine whether the id you are holding
is good.  Once it converts the id to the pointer, your pointer is
guaranteed to be good until the function returns.

These functions are named ipmi_xxx_pointer_cb(), where ``xxx'' is
control, entity, domain, or sensor.  Unlike many other callbacks, the
callback function you provide to these functions will be called
immediately in the same thread of execution, this callback is not
delayed or spawned off to another thread.  So, for instance, you can
use data on the stack of the calling function and pass it to the
callback function to use.

For instance, suppose you have a callback registered with the domain
for finding when new entities are ready, and you are looking for a
specific entity.  The code might look like:

@example
ipmi_entity_id_t my_entity_id = IPMI_ENTITY_ID_INVALID;

static void
entity_change(enum ipmi_update_e op,
	      ipmi_domain_t      *domain,
	      ipmi_entity_t      *entity,
	      void               *cb_data)
@{
    ipmi_entity_id tmp_id;

    switch (op) @{
	case IPMI_ADDED:
            if (entity_i_care_about(entity))
                my_entity_id = ipmi_entity_convert_to_id(entity);
	    break;

	case IPMI_DELETED:
            tmp_id = ipmi_entity_convert_to_id(entity);
            if (ipmi_cmp_entity_id(my_entity_id, tmp_id) == 0)
                ipmi_entity_id_set_invalid(&my_entity_id);
	    break;

        default:
            break;
    @}
@}
@end example

In this example, the entity is locked in this call, because you have
received a pointer to the entity in the callback.

However, suppose you want to use the entity id later because the user
asks about the entity to see if it is present.  You might have a piece
of code that looks like:

@example
static void
my_entity_id_cb(ipmi_entity_t *entity, void *cb_data)
@{
    my_data_t *data;

    data->exists = 1;
    data->present = ipmi_entity_is_present(entity);
@}

void
check_if_my_entity_present(my_data_t *data)
@{
    int rv;

    data->exists = 0;
    data->present = 0;
    rv = ipmi_entity_pointer_cb(my_entity_id, my_entity_id_cb, data);
    if (rv)
        printf("The entity could not be found\n");
@}
@end example

Most of the data about the various OpenIPMI objects is static, so you
can pre-collect the information about the objects in the callback
where there existance is reported.  The only dynamic variable in
OpenIPMI is entity presence.  Also, many operation require a message
to the remote system; the ones that take callbacks.  For these
operation, functions that directly take the id are available.

The entity presence code could be rewritten using this to be:

@example
void
check_if_my_entity_present(my_data_t *data)
@{
    int rv;

    data->exists = 0;
    data->present = 0;
    rv = ipmi_entity_id_is_present(my_entity_id, &data->present);
    if (rv)
        printf("The entity could not be found\n");
    else
        data->exists = 1;
@}
@end example

So, it is recommended that you collect all the static information that
you need from an object when it is reported to you.

@node    OpenIPMI Objects, Callbacks, Locking, OpenIPMI Concepts
@section OpenIPMI Objects

In OpenIPMI, the user deals with six basic objects: connections,
domains, entities, sensors, controls, and events.

@subsection Connections

A connection provides the low-level interface to the system.  It is
usually a connection to a BMC in a system.  It handles getting IPMI
messages to the proper elements in the system.

@subsection Domains

The domain is the container for the system, the entities in the system
are attached to the it.  You create a domain with a connection to a
system; the domain handles the job of discovery of the things in the
system.

@subsection Entities

Entities are things that are monitored.  They may be physical things
such as a power supply or processor, or more abstract things such as the
set of all power supplies or the ambient air in a chassis.  Sensors
monitor entities, and controls are attached to entities.

Entities may be grouped inside other entities, thus an entity may have a
parent (if it is grouped inside another entity) and children (if it
contains other entities).  These relationships are abstract; you may
change them if it you like.  A raw system with no SDR data will not have
any relationships defined.  Relationships are stored in the SDR
repository, you may change them and store them back, if you like and if
the system supports that.

FRU information about the entity is sometimes available.  You can
register with an entity to see if/when it becomes available using
@code{ipmi_entity_set_fru_update_handler()}.  Once it is available,
you can fetch the FRU data using the commands defined in the IPMI
include file.

@subsubsection Device-Relative vs System-Relative Entities

In IPMI, entities may be be either in a fixed place in the system, or
they may be moved about the system.  Fixed entities, are, well, in a
fixed location in the system.  These are called system relative
entities.  They have an entity instance less than 60h.

Other entities may not reside in a fixed location.  For instance, a
power supply or CompactPCI board may be plugged in to one of many
locations in a chassis; it doesn't know ahead of time which one.
These types of entities are generally device-relative and have an
entity instance of 60h or larger.  For these types of entities, the
management controller on which they reside becomes part of the entity.
In OpenIPMI, the IPMB channel number of IPMB address are part of the
entity.  In @command{ipmi_ui}, these are printed and entered as
``r<channel>.<ipmb>.<entity id>.<entity instance>''.

@subsection Sensors

Sensor monitor something about an object.  IPMI defines many types of
sensors, but groups them into two main categories: Threshold and
discrete.  Threshold sensors are ``analog'', they have continuous (or
mostly continuous) readings.  Things like fans speed, voltage, or
temperature.

Discrete sensors have a set of binary readings that may each be
independently zero or one.  In some sensors, these may be independent.
For instance, a power supply may have both an external power failure and
a predictive failure at the same time.  In other cases they may be
mutually exclusive, such as the initialization state of a piece of
software.

@subsection Controls

Controls are not part of the IPMI spec, but are necessary items in
almost all systems.  They are provided as part of OpenIPMI so that OEM
code has a consistent way to represent these, and so OpenIPMI is ready
when the IPMI team finally sees the light and adds controls.  OpenIPMI
defines many types of control: lights, relays, displays, alarms,
reset, one-shot-reset, power, fan speed, general outputs, one-shot
outputs, and identifiers.

For all controls except displays and identifiers, the control may
actually control more than one device.  With some controls, multiple
device may be controlled together and individual ones cannot be set (ie,
the same message sets all of them).  For these types of controls,
OpenIPMI represents them as a single control with multiple devices.
All the devices are read and set at once.

Reset controls are reset settings that can be turned on and off.
One-shot-reset controls cause a reset by setting the value to 1; they
are not readable and setting to zero returns an error.

Lights are on/off colored devices, like an LED.  They may be
multi-color, but can only show one color at a time.  For instance, if
you work for Kmart, or you are managing a CompactPCI system with
hot-swap, you will have a blue light in your system.  You can search
through the controls to find a light that's blue.  Then, if a special
is on, or you want the operator to remove a card, you can light the blue
light.  Lights may blink, too.  Each light can have settings.  Each
setting describes a sequence of one or more transitions the light may go
through.

Relays are binary outputs.  Most telephony systems have them; they are
required by telephony specs.  They are simple on/off devices.

Displays are two-dimensional arrays of characters.  OpenIPMI allows you
to change individual characters at will.

Alarms are bells, whistles, gongs, or anything to alert the user that
something is wrong.

Reset controls are used to reset the entity to which they are attached.

Power controls can be used to control power to or from an entity.  A
power control on a power supply would generally control output power.  A
power control on a board would generally control input power to the
board.

Fan speed controls can be used to set the speed of a fan.

General outputs are outputs that don't fall into one of the previous
categories.  One-shot outputs are like general outputs, but perform
some action when set to one and are not readable.  Setting them to
zero returns an error.

Identifier controls hold identification information for a system, such
as a chassis id, chassis type, geographic address, or whatever.

@subsection Events

When an external event comes into OpenIPMI, the user will always
receive that event in some manner (unless they do not register with a
generic event handler, but they should always do that).  The event may
come through a callback for a sensor, control, entity, or other
callback.

All the callbacks you should be using return a value telling whether
the handler has ``handled'' the event.  Handling the event means that
the callback is going to manage the event.  Primarily, this means that
it is responsible for deleting the event from the event log with
ipmi_event_delete().  If no callback handles the event, then it will
be delivered to the main event handler(s).  This allows calls to
receive events but the events to be managed in a single location.

If a callback handles the event, then all future callbacks called due
to the event will receive a @var{NULL} for the event.  So be ready to
handle a @var{NULL} event in all your event handlers.  A @var{NULL}
may also be passed to an event handler if the callback was not due to
an event.

@node    Callbacks, , OpenIPMI Objects, OpenIPMI Concepts
@section Callbacks

As you will discover, OpenIPMI is very callback based.  The callbacks
are somewhat fined grained; you register for exactly what you want to
see on individual objects.  This is not as bad as you might imagine
(even though it may seem somewhat strange).  It does mean that you
have to do a lot of registering in all the right places, though.  IPMI
has a large number of asyncronous things that it has to inform you
about.  If it delivered all these through one interface, you would
have to look at each call and try to figure out what type of things
was being reported, what object is was associated, etc.  In effect,
that work is done by OpenIPMI.

@subsection Updated Callbacks

Updated callbacks tell you when an object comes into existance, is
destroyed, or if configuration information about an object has
changed.  On an entity, for instance, when an entity is first added,
the entity update handler on the domain will be called with the
entity.  when an SDR is read and causes a change to the entity, the
updated handler will be called again with the change.  When the entity
is deleted, it will be called again.

In general, you should add updated handlers whenever the thing you
want to register against comes into existance.  So for entities and
the main event handler, you should register them in the setup_done
callback for the domain.  The entity update handler should register
the update handlers for sensors, controls, and FRU information.  It
should register the event handlers for presence and hot-swap there,
too.

Sensor and control update handlers should set up and register for
events from the sensor.

@subsection Event Based Callbacks

Event based callbacks tell you when asynchronous things happen in the
system.  For instance, a card gets plugged in and an entity becomes
present.  You will be told with the present callback on the entity.
The hot-swap state of an entity changes.  That is reported via the
hot-swap state callback.  Events because of sensors going out of range
is another example.

Note that the handlers don't get called with current state when you
add an event-based callback handler.

@subsection Synchronous Callbacks

Synchronous callbacks are callbacks for things you request and are
one-shot operations.  For instance, if you want to know the current
value of a sensor, you call call @code{ipmi_reading_get()} and you
give it a handler to call when the reading has been fetched.

This is always done for things that OpenIPMI might hav to send a
message to do.  If it a result of OpenIPMI's requirement to be able to
work in non-threaded systems and still be responsive to operations
while waiting.


@c **********************************************************************
@node    Using OpenIPMI, How to Write OEM Plugins, OpenIPMI Concepts, Top
@chapter Using OpenIPMI

This chapter discusses how to use the OpenIPMI library.  Note that not
all the details of everything are covered.  See the include files for
details on the functions and types.  This covers the concepts so you can
understand the include files.

@menu
* Include Files::
* Initialization::
* The Connection::
* The Domain::
* Events::
* Entities::
* Sensors::
* Controls::
* The System Event Log (SEL)::
* The Sensor Data Record (SDR) Repository::
* The Platform Event Filter (PEF)::
* Special LAN Configuration::
* Using the Automatic Platform Event Trap (PET)::
@end menu

@node    Include Files, Initialization, Using OpenIPMI, Using OpenIPMI
@section Include Files

@subsection Files the normal user deals with

@table @samp
@item @file{ipmiif.h}
The main include file for OpenIPMI.  It contains the main functions the
user must deal with when working with the OpenIPMI library.  Almost
everything will include this.  It includes @file{ipmi_types.h} and
@file{ipmi_bits.h}, too, so you don't have to include those.

@item @file{ipmi_auth.h}
The file holding information about athentication algorithms.  You need
this if dealing with an authenticated interface.

@item @file{ipmi_bits.h}
Various values, mostly for sensors, used by the user.  @file{ipmiif.h}
includes this file, so you generally don't have to include it explicitly.

@item @file{ipmi_types.h}
Types for the basic IPMI objects.  @file{ipmiif.h} includes this file,
so you generally don't have to include it explicitly.

@item @file{ipmi_err.h}
Error values, both IPMI and system, as well as macros for interpreting
these.

@item @file{os_handler.h}
The os-specific handler types are defined here.  You must implement this
and supply it to the IPMI code.

@item @file{selector.h}
For *nix systems, This file a default mechanism for handling many of the
os-specific handler operations.

@item @file{ipmi_log.h}
Holds definitions for the logging interface.

@end table

@subsection Files dealing with messaging interfaces

@table @samp
@item @file{ipmi_lan.h}
This is the LAN messaging interface, this contains the calls for
creating a LAN connection.

@item @file{ipmi_smi.h}
This is the messaging interface for talking to local IPMI interfaces
(like KCS), this contains the calls for creating an SMI connection.

@end table

@subsection File for system configuration

@table @samp
@item @file{ipmi_pef.h}
Contains code for configuring the Platform Event Filter (PEF).

@item @file{ipmi_lanparm.h}
Contains code for configuring the LAN configuration data.

@item @file{ipmi_pet.h}
Contains code that allows the user to easily set up an IPMI LAN
interface on a BMC to send traps.

@end table

@subsection Internal files that OEM code and messaging interfaces deal with

@table @samp
@item @file{ipmi_addr.h}
The file holding information about IPMI addresses.

@item @file{ipmi_conn.h}
This defines the interface for the messaging interfaces.

@item @file{ipmi_event.h}
This defines functions for handling events.

@item @file{ipmi_entity.h}
This defines internal entity interfaces.

@item @file{ipmi_fru.h}
This defines internal FRU interfaces.

@item @file{ipmi_control.h}
This defines internal control interfaces.

@item @file{ipmi_int.h}
This defines other miscellaneous internal interfaces.

@item @file{ipmi_domain.h}
This defines the internal interfaces for dealing with domains.

@item @file{ipmi_mc.h}
This defines internal interfaces for the management controllers.

@item @file{ipmi_msgbits.h}
This defines various IPMI messages.

@item @file{ipmi_oem.h}
This defines interfaces that OEM code can tie into.

@item @file{ipmi_sel.h}
This defines the internal interfaces for the SEL.

@item @file{ipmi_sdr.h}
This defines internal interfaces for the sdr repostiory.

@item @file{ipmi_sensor.h}
This defines internal interfaces for sensors.

@item @file{ipmi_locks.h}
This defines internal interfaces for locks.

@item @file{ipmi_posix.h}
This defines some POSIX OS handlers.

@end table

@node    Initialization, The Connection, Include Files, Using OpenIPMI
@section Initialization

To initialize the OpenIPMI library, you must call @code{ipmi_init()} and
pass in an @var{os_handler_t} in to it.  OpenIPMI will use this OS
handler for global operations.  This @emph{must} be done before any
other OpenIPMI calls.

Several OS handlers are pre-defined for you.  You can use the handlers
defined in @file{ipmi_posix.h} on POSIX-compliant systems.  A handler
is defined for unthreaded systems and another for threaded systems.
These use the selector code defined in @file{selector.h}.

If you need to initialize any OEM libraries, do it right after the call
to @code{ipmi_init()}.

@example
/* Initialize the OpenIPMI library. sample_cb_handler is an OS
   handler */
ipmi_init(&sample_cb_handlers);
@end example

@node    The Connection, The Domain, Initialization, Using OpenIPMI
@section The Connection

The first thing you must do after initialization is create a connection
to the IPMI system.  The operation for this depends on the type of
connection, such as a LAN connection, a connection through a local
device driver, or an OEM connection.

Note that creating a connection does not actually establish a
connection, it just creates the data structures for the connection.  You
then hand the connection to a domain.  The domain will establish the
connection and get things rolling.

Connecting to a system interface (KCS, SMIC, etc.) is relatively simple,
you need only to supply the interface number, an OS handler and a
user-defined piece of data, like:
@example
    rv = ipmi_smi_setup_con(if_num, &sample_cb_handlers, my_data, &con);
    if (rv) @{
        printf("ipmi_smi_setup_con: %s", strerror(rv));
        exit(1);
    @}
@end example

LAN connections have a lot more parameters due to authentication
requirements.  The parameters are:
@table @samp
@item  ip_addrs
The IP name or addresses of the remote BMC.  You may list
multiple IP addresses in an array, each address @strong{must} be to the
same BMC.  This is a string parameter that will be converted.
@item ports
The UDP ports to use, one for each address.  It should generally be
IPMI_LAN_STD_PORT, 623.  This is a string parameter and may also be a
service name.
@item num_ip_addrs
The number of ip addresses (and ports) in the ip_addrs and ports arrays.
@item authtype
The authentication type to use, from ipmi_auth.h
@item privilege
The privilege level to request for the connection, from
the set of values in ipmi_auth.h.
@item username
The 16-byte max username to use for the connection.
@item username_len
The length of username.
@item password
The 16-byte max password to use for the connection.
@item password_len
The length of password.
@item handlers
The set of OS handlers to use for this connection.
@item user_data
This will be put into the BMC and may be fetched by the
user.  The user can use it for anything they like.
@item new_con
The new connection is returned here.
@end table

For example, you may have the following code to set up a single address:
@example
        rv = ipmi_ip_setup_con(lan_addr, lan_port, 1,
                               IPMI_AUTHTYPE_MD5, IPMI_PRIVILEGE_ADMIN,
                               username, strlen(username),
                               password, strlen(password),
                               &sample_cb_handlers, my_data,
                               &con);
        if (rv) @{
            fprintf(stderr, "ipmi_lan_setup_con: %s", strerror(rv));
            exit(1);
        @}
@end example

@node    The Domain, Events, The Connection, Using OpenIPMI
@section The Domain

After you create a connection, you pass it into
@code{ipmi_init_domain()} to create a domain with the connection.  This
gives you back a domain that you can work with.  When the domain is
first created, it is not considered ``up'' though, you supply a callback
in the @code{ipmi_init_domain()} call which will tell you when the
connection comes up, the callback will also be used in the future to
tell you of state changes.  The id of the callback is also returned, you
can remove the callback with
@code{ipmi_domain_remove_con_fail_handler()}, and you can add more
callbacks with @code{ipmi_domain_add_con_fail_handler()}.

After the connection comes up, the OpenIPMI library starts scanning
the IPMB bus to find all MCs on the bus.  As it finds them, it will scan
the sensors on the MC and add them to entities and create new entities
as necessary.  So when OpenIPMI hands you the domain, you probably don't
have everything in the chassis.  In fact, IPMI is dynamic, so you have
to be ready for changes as they happen.

OpenIPMI will rescan the bus for new MCs every 10 minutes.  It is
expected that OEM handlers can detect new MCs with custom events and add
the new MC sooner.

Events come in through the domain.  In the setup done callback, you
should register for events with @code{ipmi_register_for_events()},
even if you are not interested in them, because you need to delete
them.  This means that your callback will receive all events that are
not attached to a sensor or otherwise handled by something inside
OpenIPMI.  If an event is attached to a sensor, it will be delivered
to a callback associated with the sensor.  Note that you may get
events on this interface even if they are destined for a sensor, if
the sensor doesn't have a handler, the sensor event handler did not
``handler'' the event, or if the event was not delivered to the user
by another mechanism.  This is so that the user can know the event
exists and needs to be deleted.

@node    Events, Entities, The Domain, Using OpenIPMI
@section Events

Events in OpenIPMI are opaque refcounted structures.  Events generally
come from the system and are given to you via callbacks.  The event
given to you in a callback @emph{may not} be kept by you, although you
can use it inside the callback function.  To keep the event for later
use, you must create a duplicate of the event using
@code{ipmi_event_dup()}.  If you duplicate an event this way, you must
free it with @code{ipmi_event_free()}.  If you do not free your
events, you will leak memory.

The events are kept in the remotely in the IPMI system event log (SEL)
and locally in a copy of the SEL.  You have to manage the SEL
yourself, if you don't then it will fill up and you will run out of
memory.  To delete events from the SEL, use
@code{ipmi_event_delete()} when you wish to delete the event.  You
can use the original event from a callback, or a duplicate you kept,
or an event fetched from the SEL.

You can look through your local copy of the SEL using
@code{ipmi_domain_first_event()}, @code{ipmi_domain_last_event()},
@code{ipmi_domain_next_event()}, and @code{ipmi_domain_prev_event()}.
Note that these function duplicate the events, so you @emph{must} free
the events you fetch with these function.

In the callback functions that receive events, you may or may not want
to manage the event from that function.  If you want to manage the
event, then return @var{IPMI_EVENT_HANDLED} and any other handler that
might be called because of that event will get a NULL.  You are
expected to free the event.  Return @var{IPMI_EVENT_NOT_HANDLED} if
you do not wish to handle the event.  Any events that are not handled
by an event handler will be delivered to the functions registered with
@code{ipmi_register_for_events()}.

@node    Entities, Sensors, Events, Using OpenIPMI
@section Entities

Entities are the things that sensors monitor and controls can change
things on.  When a domain is first reported to you as operational, you
should register a callback using
@code{ipmi_domain_add_entity_update_handler()} to tell you when
entities are added or removed.  To deregister the call, use
@code{ipmi_domain_remove_entity_update_handler()}.  That way you can
know about new entities as soon as they are created.  If you wait
until later to register the callback, entities may have come into
existance and you will miss them (although you could find them after
the fact using @code{ipmi_domain_iterate_entities()}).

As mentioned before, entities may be present or absent.  IPMI defines
a rather convoluted algorithm to detect this, but you don't have to
worry about that.  Instead, you can use the
@code{ipmi_entity_add_presence_handler()} call to register a function
to be called whenever the presence of the entity changes.  Use
@code{ipmi_entity_add_presence_handler()} to remove the presence
handler.  You can use @code{ipmi_entity_is_present()} to determine the
current presence of the entity.  Like the other callbacks, you should
register the presence callback in the entity creation callback.

Sensors and controls hang off entities.  OpenIPMI provides iterators
so you can scan all the sensors and controls on an entity.  It allows
you to register callbacks to tell you when sensors and controls are
added to or removed from the entity, using either
@code{ipmi_entity_add_sensor_update_handler()} or
@code{ipmi_entity_add_control_update_handler()}.  The handlers can be
removed with @code{ipmi_entity_remove_sensor_update_handler()} or
@code{ipmi_entity_remove_control_update_handler()}. You should do this in
the entity creation callback so you won't miss any sensors or controls
as they are detected.  You can also iterate over the current sensors
and controls using @code{ipmi_entity_iterate_sensors()} and
@code{ipmi_entity_iterate_controls()}.

Entities are hierarchical in nature.  An entity can have children
entities.  OpenIPMI allows you to create these relationships in the
local database and push them to the SDR database on the chassis, if you
like.  The next time it starts, it will pull them from the SDR database
and recreate the relationships.  If you have multiple power supplies in
a subchassis, or multiple processors on a board, the entity
relationships let you create nice containment relationships.  Use the
functions @code{ipmi_entity_iterate_children()} to find the children of
an entity, or @code{ipmi_entity_iterate_parents()} to iterate the
parents of an entity.  There doesn't seem to be a restriction in IPMI
that an entity only have one parent, thus the parent iteration call.

@node    Sensors, Controls, Entities, Using OpenIPMI
@section Sensors

Sensors, of course, are what IPMI is mostly about.  A sensor monitors
a characteristic of an entity.  IPMI specifies two main classes of
entities: threshold and discrete, described individually later.

You can tell the main type of sensor by doing an
@code{ipmi_sensor_get_event_reading_type()} call.  If this returns
@var{IPMI_EVENT_READING_TYPE_THRESHOLD}, it is a threshold sensor.
Otherwise, it is a discrete sensor.

It is important to note that all operations on a sensor are serialized,
each sensor has a queue of operations to perform, and it will only
perform one operation at a time on a sensor.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
sensor easier for the user.

@menu
* Threshold Sensors::
* Discrete Sensors::
* Sensor Events::
* Hot Swap Sensor::
@end menu

@node    Threshold Sensors, Discrete Sensors, Sensors, Sensors
@subsection Threshold Sensors

Threshold sensors measure ``continuous'' data, data that generally
measure physical constants like voltage, temperature, etc.  IPMI calls
them ``threshold'' sensors because you can set thresholds for them.
Then a threshold is exceeded, some sensors can send an event to the
event receiver in the system.

Threshold sensors, unfortunately, are exceedingly complicated.  They
have a large number of settings, many options for conversion between the
discrete values and real values, and may support many optional
settings.  OpenIPMI attempts to hide much of this complexity, but it can
only go so far.

IPMI threshold sensors have the following settings:
@table @samp
@item Scanning
The sensor can be turned on and off using the status field of
@var{ipmi_thresholds_t} by setting or clearing
@var{IPMI_SENSOR_SCANNING_ENABLED} in the bitmask.  You have to use
@code{ipmi_sensor_get_sensor_init_scanning()} function to tell if you
need to turn scanning on or off.

@item Events
Some sensors can generate events, some can't.  For more details, see
@xref{Sensor Events}.

@item Thresholds
Some sensors support thresholds.  See below for more details.

@item Hysteresis
Some sensors have hysteresis values.  The function
@code{ipmi_sensor_get_sensor_init_hysteresis()} will tell you if you
need to initialize the hysteresis value for the sensor.  The
@code{ipmi_sensor_get_hysteresis support()} tells you what type of
hysteresis (if any) the sensor supports.

@end table

IPMI specifies the following thresholds:
@table @samp
@item non-recoverable
@item critical
@item non-critical
@end table

Their meanings are not really defined by IPMI, but they should be
obvious.  Each of these can have an upper and lower type, so for
instance you can have a critical upper and critical lower voltage
threshold.  As well, each of these may support an assertion and
deassertion event (an event when the value goes beyond the given range,
and another event when the value goes back within the given range, with
possible hysteresis).

In addition, the sensor may detect going above the given threshold (a
high-going threshold) or below the given threshold (a low-going
threshold).  This may seem redundant with the upper and lower
thresholds, but that's what the spec says.

The @code{ipmi_sensor_get_event_support()} tells what type of event
support the sensor has.  The sensor may support no events, only global
(per-MC) event enable and disable, event enable and disable for the
whole sensor, or event enable and disable per-threshold.  If the sensor
supports per-thresholds enables, it will also support enable for the
whole sensor.  All sensors that support events will support global
enables.

Of course, few sensors support all possible threshold values, and you
must be able to tell what they support.  You use the
@code{ipmi_sensor_threshold_assertion_event_supported()} and
@code{ipmi_sensor_threshold_deassertion_event_supported()} functions to
tell if the sensor supports a given threshold event.  The thresholds may
or may not be readable and settable, use the
@code{ipmi_sensor_threshold_settable()} and
@code{ipmi_sensor_threshold_readable()} to tell if a threshold can be
set or read.

To turn on and off thresholds and support for events and to set the
thresholds, you must first fill out an @var{ipmi_event_state_t}
structure using the various calls defined to do this.  Then call
@code{ipmi_sensor_events_enable_set()} to set the values to exactly the
given settings.  The current values may be fetched with
@code{ipmi_sensor_events_enable_get()}.  If you just want to enable or
disable specific events without affecting the states of other events,
you can use @code{ipmi_sensor_events_enable()} and
@code{ipmi_sensor_events_disable()} to enable and disable specific
events.

To fetch the current value for a threshold sensor, use the
@code{ipmi_reading_get()} function.  The callback also returns the
current states of the various thresholds.  To see if a specific
threshold is out of range, use @code{ipmi_is_threshold_out_of_range()}
on the states passed in.

The SDR also has information about the accuracy, tolerance, min and max
values, etc. for the sensor.  OpenIPMI contains functions that return
these as floating point values (converted from raw values).  You need to
read the IPMI spec for the real meanings of all these things (from what
little is provided there), the functions are under the comment ``Sensor
reading information from the SDR'' in @file{ipmiif.h}.

OpenIPMI provides string values for many of the values in the SDR, so
the user doesn't have to provide it.  Note that the string may be set to
a valid value even if the numeric value in the SDR is an invalid or OEM
one, OEM code may update the string.  The string values are provided by
functions under ``Strings for various values for a sensor'' in
@file{ipmiif.h}.

@node    Discrete Sensors, Sensor Events, Threshold Sensors, Sensors
@subsection Discrete Sensors

IPMI represents discrete sensors as a bitmask, each bit representing a
possible discrete state.  One bit is reserved for other use.  This
limits you to 15 possible states for each sensor, but that's generally
not a big deal.  These are called ``offsets'' or ``states'' by the IPMI
spec, and are numbered from 0 to 14.

To get a reading from a discrete sensor, use the
@code{ipmi_states_get()} function.  The callback gives a variable
of @var{ipmi_states_t} type, use the @code{ipmi_is_state_set()} function
to tell if a specific discrete state is set.

The meanings of the reading's offsets are specified one of two ways.
This is specified by the @code{ipmi_sensor_get_event_reading_type()}.  A
value of @var{IPMI_EVENT_READING_TYPE_THRESHOLD} means a threshold
sensor.  A value of @var{IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC} means
the reading depends on the sensor type.  Values 0x2-0xc are generic
readings that can apply no matter what the sensor type, and are
specified in the IPMI spec.

If the reading offset meaning depends on the sensor type, you must call
@code{ipmi_sensor_get_sensor_type()} to retrieve the sensor type.  You
can use this to tell what the reading means.

You can also pass the offset of a reading (the state number that is set)
info @code{ipmi_sensor_reading_name_string()} to get string values for
the offsets.  This works for generic and for sensor-specific reading
types.  The string values may be valid even if the sensor is OEM or has
OEM values, because the OEM code can put there own strings in here.

@node    Sensor Events, Hot Swap Sensor, Discrete Sensors, Sensors
@subsection Sensor Events

Both threshold and discrete sensors support events, and they work about
the same for both, if you think of a threshold as a discrete state.
Individual discrete states may be armed to generate events.  However,
not all sensors support events, you need to use the
@code{ipmi_sensor_threshold_assertion_event_supported()},
@code{ipmi_sensor_threshold_deassertion_event_supported()},
@code{ipmi_sensor_discrete_assertion_event_supported()}, and
@code{ipmi_sensor_discrete_deassertion_event_supported()} calls to tell
if the particular sensor supports events on the given threshold or
state.

You can turn event generation on and off for sensors that support it
using the status field of @var{ipmi_event_state_t} by setting or
clearing @var{IPMI_SENSOR_EVENTS_ENABLED} in the bitmask.  You must
first initialize the structure with @var{ipmi_event_state_init}, then
set the specific events you are interested in using the
@code{ipmi_threshold_event_set()}, @code{ipmi_threshld_event_clear()},
@code{ipmi_discrete_event_set()}, and
@code{ipmi_discrete_event_clear()}, then call
@code{ipmi_sensor_events_enable_set()} to set the thresholds.  You can use
@code{ipmi_sensor_events_enable_get()} to fetch the current events
setting. You have to use @code{ipmi_sensor_get_sensor_init_events()}
function to tell if you need to initialize the events.  The
@code{ipmi_sensor_get_event_support()} function returns the support for
events.

You register to receive events for a sensor with
@code{ipmi_sensor_set_event_handler()}, which sets a callback that gets
called when an event comes in from the given sensor.  When the callback
comes in, the information from the event is presented, depending on the
sensor type.

For all sensor types, the direction (whether the state causing the event
is being asserted or deasserted) is present.  The offset specifies the
specific state or threshold that caused the event to be asserted.  The
@var{value_present} tells if a value is present, and whether it's raw or
cooked.

If an IPMI event (one that will now be in the SEL) caused this event,
then the event field will point to the event that caused this.  The
event is not automatically deleted from the SEL, you must do this
yourself.  This way, you can make sure the event has been properly
handled before removing it from the SEL.  Note that you @emph{must}
delete the events, or you SEL will fill up.

@node    Hot Swap Sensor, , Sensor Events, Sensors
@subsection Hot Swap Sensor

A discrete sensor for an entity may be a hot-swap requester, meaning
that it is a sensor that detects when the user wants to remove a board.
The @code{ipmi_sensor_is_hot_swap_requester()} call will return true if
the sensor passed in has the hot-swap requester.  It also returns the
offset for the hot-swap sensor, and whether the value will be asserted
when requested or not asserted when requested.

This way, upper-level software can detect if a sensor is a hot-swap
sensor and handle it properly.  Note that a sensor (such as a standard
slot sensor) may have more things in it than just the hot-swap
requester.

@node    Controls, The System Event Log (SEL), Sensors, Using OpenIPMI
@section Controls

As mentioned before, the IPMI standard does not currently define any way
to control output devices.  Of course, this is a huge hole, and is
likely to be filled in the future.  Until then, OpenIPMI defines an
abstraction for handling output devices.  This abstraction is hopefully
good enough for whatever the IPMI committee comes up with in the future,
but there will certainly be changes when it is specified.

Controls are input/output devices.  They may generate events, they
have values which can be (optionally) set and (optionally) read.
These are relatively simple devices currently, although the IPMI
committee is sure to complicate things in the future.

It is important to note that all operations on a control are serialized,
each control has a queue of operations to perform, and it will only
perform one operation at a time on a control.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
control easier for the user.

Unfortunately, some hardware does not have individually settable
devices, a set of devices may all be set at once.  This sometimes makes
sense, but usually makes things difficult for the user.  There's not
much OpenIPMI can do about this but pass the difficulty on up to the
user.  Thus, each control may have one or more instances of a device it
controls.  All these devices must be set at once, you cannot
individually set the devices inside one control.

Most controls have individually settable values that are integers.  Some
controls, namely displays and identifiers, have special needs and are
thus represented specially.

Simple controls are set and read by the @code{ipmi_control_set_val()}
and @code{ipmi_control_get_val()} functions.  As well, some control
may be able to generate events when their values change.  If an event
can do this, then @code{ipmi_control_has_events()} will return true
for the control, and you can add and remove an event handler using
@code{ipmi_control_add_val_event_handler()} and
@code{ipmi_control_remove_val_event_handler()} for simple controls.

@menu
* Simple Controls::
* Lights::
* Fan Speed::
* Identifiers::
* Displays::
* Hot Swap Control::
@end menu

@node    Simple Controls, Lights, Controls, Controls
@subsection Simple Controls

Simple controls are on/off devices, the values provided are binary
values.  They are different because they control different types of
devices.  These are:

@table @samp
@item Relays - Generally telco relays on a chassis, but any type of relay.
@item Alarms - Visual or audible devices to get a user's attention.
@item Reset - The reset line on a board or device.
@item Power - The power output from a power supply, or power input to a
        device.
@end table

@node    Lights, Fan Speed, Simple Controls, Controls
@subsection Lights

Lights are slightly more complicated than simple devices.  Lights have
colors and blinking settings that must be represented.

Two types of lights exist, ones that have a fixed number of settings
(blink and color), called a transition light, and ones that can have
their blink and color set to arbitrary values, called a setting light.

The function ipmi_control_light_set_with_setting() returns true if the
light is a setting light and false if it is a transition light.

If this seems complicated, well, it is.  Sorry, there's a lot to
represent here.

@subsubsection Transition Lights

For transition lights, each setting is represented by a single integer
value, and a setting is a series of one or more transitions the light
will go through.  Each transition has a color and duration.  And, of
course, more than one light may be supported in a single control.

The @code{ipmi_control_get_num_light_settings()} function returns the
number of settings a specific light has.  These are defined to be
continuous, if it reports 6, for instance, then the light will have
settings 0-5.

The @code{ipmi_control_get_num_light_transitions()} function returns the
number of transitions for a setting.

The @code{ipmi_control_get_light_color()} function returns the color a
light will be at a specific setting.

The @code{ipmi_control_get_light_color_time()} function returns the time in
milliseconds the transition is valid, before it goes to the next
transition.  This is used to represent blinking modes.  For instance, if
an LED in setting 4 blinks red for 100ms, green for 200ms, then off for
a second, then setting 4 will have 3 transitions, the first will be red
with 100, the second will be green with 200, the last will be black with
1000.

@subsubsection Setting Lights

For setting lights, you can determine if a specific color is supported
with @code{ipmi_control_light_color_is_supported()}.  You get the
light setting with @code{ipmi_control_get_light()} and set the light setting
with @code{ipmi_control_set_light()}.

@node    Fan Speed, Identifiers, Lights, Controls
@subsection Fan Speed

Fan speed allows the user to control the speed of a fan.  FIXME - This
is still TBD, need ways to find the min/max values and number of
settings.

@node    Identifiers, Displays, Fan Speed, Controls
@subsection Identifiers

Identifiers are things on a device that identify characteristics of that
device.  For instance, a unique serial number or a device type would be
identifiers.  These are represented as an array of unsigned characters,
as some identifiers may be very large.  The length may be variable,
too.

The function @code{ipmi_control_identifier_get_val()} and
@code{ipmi_control_identifier_set_val()} let you read and (optionally)
change the value of an identifier.  If you need to know the maximum
length, the function @code{ipmi_control_identifier_get_max_length()}
returns that.  The actual length is returned in the reading when you get
it.

@node    Displays, Hot Swap Control, Identifiers, Controls
@subsection Displays

FIXME - displays are TBD.

@node    Hot Swap Control, , Displays, Controls
@subsection Hot Swap Control

A control may be the indicator used to tell the user it's safe to remove
a hot-swap device (like the blue LED in Compact PCI).  If an indicator
is the hot-swap indicator, it should be a single LED, and the function
@code{ipmi_control_is_hot_swap_indicator()} will return true for it.

@node    The System Event Log (SEL), The Sensor Data Record (SDR) Repository, Controls, Using OpenIPMI
@section The System Event Log (SEL)

The SEL on a system receives all the events from a system and stores
them in a non-volatile store.  Depending on the capabilities of the BMC,
these may also have been received via an event message from the system
event queue.  OpenIPMI manages the received events, scans the SEL
periodically, and delivers the messages.  It discards duplicates.
Events that OpenIPMI can correlate to a specific sensor or control will
be delivered to the user through that sensor/control.  Events it cannot
interpret properly will be delivered through a generic interface for the
domain.

OpenIPMI keeps a local copy of the SEL in memory, but it doesn't
currently use very efficient methods to manage it.  The user should
receive the events and delete them in a timely manner to keep the SEL
small.  Note that if your SEL entity in your system doesn't support
deleting individual entries, then you must deleted @emph{all} the local
entries in the local copy of the SEL before OpenIPMI will clear the
entries from the SEL in the device.

When OpenIPMI scans the MCs, it checks the SEL device capabilities bit
and sets up an SEL for each MC that has that bit set.  This means that
multiple MCs may have an SEL.  When traversing the SEL, OpenIPMI will go
through @emph{all} the SEL devices on all MCs.  Also, events have the id
of the MC they came from so they can be traced back to their source.

The @code{ipmi_register_for_events()} function allows you to get events
OpenIPMI couldn't correlate to a sensor.  As well, the functions
@code{ipmi_domain_first_event()}, @code{ipmi_domain_last_event()},
@code{ipmi_domain_next_event()}, and @code{ipmi_domain_prev_event()} let you
iterate through the events in the local representation of the SEL.

@node    The Sensor Data Record (SDR) Repository, The Platform Event Filter (PEF), The System Event Log (SEL), Using OpenIPMI
@section The Sensor Data Record (SDR) Repository

OpenIPMI has code to manage the SDR Repository on the machine.

FIXME - this section needs information.

@node    The Platform Event Filter (PEF), Special LAN Configuration, The Sensor Data Record (SDR) Repository, Using OpenIPMI
@section The Platform Event Filter (PEF)

The Platform Event Filter (PEF) allows IPMI events to be forwarded as
SNMP traps, cause system operations such as power and reset
operations, and it allows IPMI events to cause the BMC to dial
page.  The filters present can search for certain information in
events, and if the information matches to cause the appropriate events
to occur.

The PEF include file @file{ipmi_pef.h} defines the type
@var{ipmi_pef_t}.  You must allocate one of these with
@code{ipmi_pef_alloc()}, it will go find the information and return
the new PEF via a callback when done.

This @var{ipmi_pef_t} type is designed for fairly low-level access,
you directly access the configuration parameters, but you have to
handle all the locking yourself.  If you want easier access to the
configuration, a @var{ipmi_pef_config_t} type is provided that is able
to handle the full configuration process.

You can get an @var{ipmi_pef_config_t} from an @var{ipmi_pef_t} object
using the @code{ipmi_pef_get_config()} call, which fetches the whold
configuration and calls a callback with the results.  If you receive
the configuration without an error, the PEF is locked.  If you get an
error, the PEF is not locked.  You @emph{must} unlock it, or access
will be blocked to the PEF for others.  You can unlock it using
@code{ipmi_pef_set_config()}, which writes the configuration back out
to the PEF, or with @code{ipmi_pef_clear_lock()}, which just clears
the lock without committing the changes.  Note that the get and set
operations can involve quite a bit of messaging, as the configuration
can be quite large.

If you get an @var{EAGAIN} error from fetching the configuration, that
means someone else is holding the lock.  If you are sure the lock was
left in a bad state, you can unlock it directly with
@code{ipmi_pef_clear_lock()} passing in a NULL for the PEF
configuration.

You can fetch and change your @var{ipmi_pef_config_t} type using the
many get and set functions defined in the include file.  However, any
changes you make are only made to the local copy, not the real PEF.
You must write any changes using @code{ipmi_pef_set_config()}.

The actual meaning of the configuration items is defined in the IPMI
specification, see that for more details.

@node    Special LAN Configuration, Using the Automatic Platform Event Trap (PET), The Platform Event Filter (PEF), Using OpenIPMI
@section Special LAN Configuration

IPMI provides a way to configure the LAN interface through IPMI
messaging, the @var{ipmi_lanparm_t} type defined in the
@code{ipmi_lanparm.h} include file represents this interface for the
user.  You allocate one of these with @code{ipmi_lanparm_alloc()}.

This @var{ipmi_lanparm_t} type is designed for fairly low-level
access, you directly access the configuration parameters, but you have
to handle all the locking yourself.  If you want easier access to the
configuration, a @var{ipmi_lanparm_config_t} type is provided that is
able to handle the full configuration process.

You can get an @var{ipmi_lanparm_config_t} from an
@var{ipmi_lanparm_t} object using the @code{ipmi_lan_get_config()}
call, which fetches the whold configuration and calls a callback with
the results.  If you receive the configuration without an error, the
LAN configuration is locked.  If you get an error, the LAN
configuration is not locked.  You @emph{must} unlock it, or access
will be blocked to the LAN configuration for others.  You can unlock
it using @code{ipmi_lan_set_config()}, which writes the configuration
back out to the LANPARM, or with @code{ipmi_lan_clear_lock()}, which
just clears the lock without committing the changes.  Note that the
get and set operations can involve quite a bit of messaging, as the
configuration can be quite large.

If you get an @var{EAGAIN} error from fetching the configuration, that
means someone else is holding the lock.  If you are sure the lock was
left in a bad state, you can unlock it directly with
@code{ipmi_lan_clear_lock()} passing in a NULL for the LAN configuration.

You can fetch and change your @var{ipmi_lanparm_config_t} type using
the many get and set functions defined in the include file.  However,
any changes you make are only made to the local copy, not the real
LANPARM.  You must write any changes using
@code{ipmi_lan_set_config()}.

The actual meaning of the configuration items is defined in the IPMI
specification, see that for more details.

@node    Using the Automatic Platform Event Trap (PET), , Special LAN Configuration, Using OpenIPMI
@section Using the Automatic Platform Event Trap (PET)

Setting up the PEF and LAN configuration to properly receive traps,
well, it just kind of sucks.  There's a ton of things to configure.
But you can use the PET code to set up the PEF and LAN configuration
to forward SNMP traps to a system.  The interface is described in
@file{ipmi_pet.h}.  The PET will configure the PEF and LAN using the
table numbers you provide, and will periodically check it to make sure
it stays correct.

Note that OpenIPMI does not have any code to receive the traps from a
socket, since that depends on a lot of things.  You will have to set
up the socket and receive and parse the traps.  Once you have the data
extracted from the trap, you can call
@code{ipmi_handle_snmp_trap_data()} to actually try to interpret the
trap.  The @file{ui/basic_ui.c} code has an example of how to use the
UCD SNMP stack to do this.

Currently, OpenIPMI only uses the presence of a trap to trigger a SEL
fetch.  That's because the IPMI trap does not have enough information
to determine the correct sensor (it's missing the channel and LUN) and
it does not have enough information to correlate the SEL entries with
the trap (It doesn't have the record ID or necessarily the proper
timestamp).  If you cannot correlate the traps with SEL entries, you
can get duplicate events, which would be bad.

@node    How to Write OEM Plugins, Debugging Your Application, Using OpenIPMI, Top
@chapter How to Write OEM Plugins

Many things need to be represented that are not currently part of IPMI.
That's life, no standard can do everything.  Thus, OEM code needs to be
written for handling specific MCs.  In general, the MC is the primary
place that OEM code ties in.

An example of an OEM plugin is given in @file{example_oem.c}, it
contains a lot of useful info (including an example of how to do direct
I2C access and represent it as a sensor).

An OEM handler should register itself with the
@code{ipmi_register_oem_handler()} function.  It registers with a
manufacturer id and product id.  When an MC with those values is
detected, the OEM handler supplied in the function is called.  Then the
OEM handler can perform the functions it needs to do for that MC.

@menu
* Connections::
* Fixups::
* Non-Standard Sensors::
* OEM Controls::
* Special Strings::
* Data Conversion::
* Special Event Handling::
* Using IDs in OEM Code::
* Sensor and Control Operation Queues::
* SDR Repository and OEM Code::
@end menu

@node    Connections, Fixups, How to Write OEM Plugins, How to Write OEM Plugins
@section Connections

Some connections need to be able to handle certain things.  The primary
one is that the IPMB address for the connection must be set properly,
and sometimes when you connect to an MC it is not at IPMB address 0x20
(in many blade-based systems, for instance).

If an IPMB address can change, it should bind in an OEM connection
handler for @code{ipmi_register_oem_conn_handler()}.  That handler
should set the @code{get_ipmb_addr} function pointer in the connection
to its own handler.  The connection will call this function at startup
to determine the IPMB address, and it will call this function
periodically to see if the IPMB address changes.  The connection code
will use this to monitor the IPMB address and take action when it
changes.

If a connections has the concept of being ``active'' and ``standby'', it
should set the @code{set_active_state} function pointer in the
connection so it can change the state of the connection as necessary.
For an active/standby system to work, setting a connection as active
should automatically (or at least as part of @code{set_active_state})
deactivate the other connections.

@node    Fixups, Non-Standard Sensors, Connections, How to Write OEM Plugins
@section Fixups

Well, it happens.  Some bit is set wrong in the MC, or in a sensor SDR,
and that screws things up.  OEM code can directly fix values in the MC
using the calls in @file{ipmi_mc.h}.

For sensors, the OEM code can register to be told when new sensors are
added via the @code{ipmi_mc_set_oem_new_sensor_handler()} function.  It
should do this in the main OEM callback.  Every sensor that comes from
that MC will be supplied as it is detected from the device SDRs.  The
OEM code can then fix values in the sensor.  Note that any sensors from
the main SDR repository will not be called this way, since they will
already exist before the MC is detected.  If these exist, the OEM code
will have to scan the existing sensors and fix them up.

@node    Non-Standard Sensors, OEM Controls, Fixups, How to Write OEM Plugins
@section Non-Standard Sensors

Some sensors may not be properly represented in the SDR, or perhaps
there's some sensor on the I2C bus that doesn't have an MC managing it,
or perhaps a sensor that is accessed in a non-standard way.  Although
this is not how IPMI is supposed to work, OEM code can handle this and
represent these sensors as though they were standard IPMI sensors.

During the process of adding sensors and entities, the OEM code should
claim the entity lock in the MC using @code{ipmi_domain_entity_lock()},
and unlock it with @code{ipmi_domain_entity_unlock()} to keep the entity
list from changin while this is happening.

If the entity that holds the sensor doesn't exist, you will need to
create it with @code{ipmi_entity_add()}.  It should create any
parent-child relationships as required using
@code{ipmi_entity_add_child()}.  If the entity already exists, it needs
to be found, and a lock for the entity needs to be held.

OEM code can allocate a sensor using
@code{ipmi_sensor_alloc_nonstandard()}, then fill in all the values for
the sensor.  Sensor functions that need to send messages are
polymorphic, the @var{ipmi_sensor_cbs_t} structure defines all the
functions for a sensor.  You can fetch the current callbacks with
@code{ipmi_sensor_get_callbacks()}, change them, then set them with
@code{ipmi_sensor_set_callbacks()}.  The sensor will keep a copy of the
callbacks, so you don't have to allocate or manage this data.  This way,
you can supply your own version of these callbacks and override the
standard functions.

Sensors have an OEM pointer that the OEM code can use, the functions
@code{ipmi_sensor_set_oem_info()} and @code{ipmi_sensor_get_oem_info()}
set and retrieve this value.  A cleanup handler may be provided, if not
NULL this will be called with the sensor and OEM info when the sensor is
destroyed.

After the sensor has been set up, it can be added to the MC with
@code{ipmi_sensor_add_nonstandard()}.  These sensors are added in as LUN
4 to separate them from the normal sensors.  You must provide the entity
for the sensor, the MC it belongs to, and a sensor number.  The sensor
number is important, if you need to create an ID for the sensor (as
described in @xref{Using IDs in OEM Code}.) you need to be able to
determine the number for the sensor.  You may also provide a handler to
be called when the sensor is destroyed.

@node    OEM Controls, Special Strings, Non-Standard Sensors, How to Write OEM Plugins
@section OEM Controls

Because IPMI doesn't define output devices, all controls are
non-standard.  But they still need to be represented.  Controls work
just like sensors as defined in @xref{Non-Standard Sensors}, see that
for details on how to add your own sensors.

@node    Special Strings, Data Conversion, OEM Controls, How to Write OEM Plugins
@section Special Strings

As described in @xref{Fixups}, sensors can be detected as they are added
to the local database.  If the sensor is an OEM type, has it's own
units, or whatever, they can set their own strings for
these values.  The functions are defined in ``Custom sensor strings''.

Also, custom offsets may also have their own strings defined.  You must
override the @var{ipmi_sensor_reading_name_string} in the sensor
callbacks and provde you own function to convert the readings to
strings.

@node    Data Conversion, Special Event Handling, Special Strings, How to Write OEM Plugins
@section Data Conversion

As described in @xref{Fixups}, sensors can be detected as they are added
to the local database.  If a sensor has a custom data conversion
function, it can provide a converter by overriding the
@var{ipmi_sensor_convert_from_raw} and @var{ipmi_sensor_convert_to_raw}
variables in the sensor callbacks.

@node    Special Event Handling, Using IDs in OEM Code, Data Conversion, How to Write OEM Plugins
@section Special Event Handling

An MC with an SEL may need custom handling for incoming events.  The
@code{ipmi_mc_set_sel_oem_event_handler()} call allows the OEM code to
set a handler that will be called when a new event is stored in the MC's
SEL.  If this function returns 1, that means the function handled the
event and no more handling should occur on the event.  If these function
return 0, the code will continue event handling.

An MC may also send custom events that might need to be handled in a
special way.  The @code{ipmi_mc_set_oem_event_handler()} will set a
callback to receive events that come from the MC.  If this function
returns 1, that means the function handled the event and no more handling
should occur on the event.  If these function return 0, the code will
continue event handling.

Note that if the OEM code handles an event but doesn't deliver it to the
user, it should call @code{ipmi_handle_unhandled_event()} so that the
user can be informed of the event (and thus can delete it if they
like).

Also, OEM code should ignore events with old timestamps (before the
startup of the system).  The OEM code can fetch the event from the
timestamp, and it can get the SEL timestamp at startup using
@code{ipmi_mc_get_startup_SEL_time()}.

@node    Using IDs in OEM Code, Sensor and Control Operation Queues, Special Event Handling, How to Write OEM Plugins
@section Using IDs in OEM Code

OEM code may need to be able to create its own IDs to lock an entity.
For instance, if a custom even comes in and a lock need to be claimed
for an object, it may fill in an id structure.  The @file{ipmi_types.h}
file holds the definitions for these structures, they need to be filled
out completely.

@node    Sensor and Control Operation Queues, SDR Repository and OEM Code, Using IDs in OEM Code, How to Write OEM Plugins
@section Sensor and Control Operation Queues

As described in @xref{Sensors}, operations on sensors (and controls) are
serialized.

Each sensor and control has an operation queue, or opq.  The OEM code
should use this opq to perform operations that do messaging.  OpenIPMI
handles the locking for the sensors and controls, so this actually makes
it more convenient to use.

If OEM code needs to send a command for a sensor, it should use the
functions defined to do that for sensors and controls.  That way,
OpenIPMI can handle the locking of the sensor or control for the OEM
code.

The section in @file{ipmi_sensor.h} named ``Operations and callbacks for
sensor operations'' and the section in @file{ipmi_control.h} named
``Operations and callbacks for control operations'' describes this in
detail.

@node    SDR Repository and OEM Code, , Sensor and Control Operation Queues, How to Write OEM Plugins
@section SDR Repository and OEM Code

OpenIPMI has OEM plugins that allow the OEM code to handle OEM SDR
records and generate their own SDR records.  Sensors and entities have
polymorphic calls that are called when an SDR entry is written to the
SDR respository for one of them.

FIXME - need to finish this out.

@node    Debugging Your Application, Internals, How to Write OEM Plugins, Top
@chapter Debugging Your Application

OpenIPMI has some things to help you debug your application (and
OpenIPMI itself).  Note that these debugging interfaces are subject to
change.

@menu
* Debug Flags::
* Debugging Locking::
* Seeing IPMI Messages::
@end menu

@node    Debug Flags, Debugging Locking, Debugging Your Application, Debugging Your Application
@section Debug Flags

OpenIPMI has a set of flags you may set to enable or disable certain
debugging information generation.  Debugging information goes to the log
output with IPMI_LOG_DEBUG[_yyy] types.  To enable a flag, do a
@code{DEBUG_xxx_ENABLE()} call, where xxx is the name of the flag.  To
disable a flag, so a @code{DEBUG_XXX_DISABLE()} call.  To check to see
if a flag is enabled (for OEM code, for instance), use the
@var{DEBUG_xxx} macro.

@node    Debugging Locking, Seeing IPMI Messages, Debug Flags, Debugging Your Application
@section Debugging Locking

The LOCKS flag turns on locking (if the @var{IPMI_CHECK_LOCKS}
preprocessor variable is defined, which it is by default).  If you
enable locking, OpenIPMI will check everywhere that the proper locks are
held, and do other checks depending on what low-level OS handling code
is in place, and complain if things aren't right.  You can set a
breakpoint at the function @code{ipmi_report_lock_error()} to have a
debugger stop when a lock problem occurs.

The lock checking is somewhat expensive, and if you want to remove the
calls, you can remove the definition of @var{IPMI_CHECK_LOCKS} from
the file Makefile.am.

@node    Seeing IPMI Messages, , Debugging Locking, Debugging Your Application
@section Seeing IPMI Messages

Two flags control message tracing.  Setting the MSG flag will turn on
message tracing of IPMI messages.  If you turn on RAWMSG, it will trace
low-level messaging, such as LAN resends and any other protocol-type
messages.  This depends on the interface, some interfaces don't
implement raw message tracing.

@node    Internals, The IPMI LAN Server, Debugging Your Application, Top
@chapter Internals

This section describes the internals of OpenIPMI.  These details are
subject to change, so don't depend on them for writing portable
software.

@menu
* How Locking Works::
@end menu

@node    How Locking Works, , Internals, Internals
@section How Locking Works

The locking in OpenIPMI is currently rather course-grained, for
simplicity.  In the future, it will probably be more fine-grained.

The system has one read/write lock that protects access to the list of
domains.  Every operation locks this lock read (except for the ones that
modify it, which lock it write).  This prevents a domain from going away
while it's in use.

Every domain has an @var{mc_list_lock}, that lock is used to lock all
MC's in the domain.  As well, there is an @var{entities_lock} in the
domain, it is locked for any entities in the domain.

SDRs, since they may stand alone after their underpinnings have been
destroyed, have their own lock.

The various interfaces have their own locks, too, for handling sequence
numbering and the like.  These are interface-dependent and should not
concern the user since they shouldn't be held during user calls.

@node    The IPMI LAN Server, Concept Index, Internals, Top
@chapter The IPMI LAN Server

OpenIPMI also includes software to represent a system interface (KCS,
SMIC, BT) as a LAN connection.  It consists of the following parts:

@table @samp
@item @file{lanserv_ipmi.c}
A system independent IPMI LAN protocol engine.  You could use this to
build your own IPMI LAN protocol on your own system.

@item @file{lanserv_asf.c}
The ASF-specific code, again machine independent.  It handles the RCMP
portion of the IPMI LAN connection.

@item @file{lanserv.c}
The Linux-specific code for the IPMI LAN connection.  It parses the
configuration file, handles I/O, etc.

@item @file{lanserv.h}
The include file for the system-independent portions of the IPMI lan
server.

@end table

The man page for @file{ipmilan} describes how to use the LAN server, see
that for more details.

@node    Concept Index, Glossary, The IPMI LAN Server, Top
@unnumbered Concept Index

@printindex cp

@node    Glossary, OEM Specific Information, Concept Index, Top
BMC
domain
connection
callback
discrete sensor
entity
FRU
OpenIPMI id
IPMB
IPMI
LUN
MC
presence sensor
SDR
SEL
slave address
threshold
threshold sensor

@node    OEM Specific Information, , Glossary, Top
@chapter OEM Specific Information

This chapter describes the workings of OEM-specific code, you should
read the chapters of interest if using hardware that has OEM-specific
handling in OpenIPMI.

@menu
* Force Computers::
* Motorola MXP::
* ATCA::
@end menu

@node    Force Computers, Motorola MXP, OEM Specific Information, OEM Specific Information
@section Force Computers

Force Computers CompactPCI system are supported by OpenIPMI, including
getting and setting the board address.  It's transparent, the only
thing to remember is that OpenIPMI will force the connection it uses
to be address 0x20 and will force anything else on the bus back to its
normal address.

The reason for this is for support for multiple interfaces.  If you
are running lanserv on two cards in the system, OpenIPMI can connect
to both of them and will make one of the active and one standby.
OpenIPMI will automatically switch over on failures.

You can disable this feature by commenting out the appropriate
sections in oem_force_conn.c.

@node    Motorola MXP, ATCA, Force Computers, OEM Specific Information
@section Motorola MXP

The Motorola MXP chassis provides a PICMG 2.16 backplane, support for
dual switch cards, and access via Ethernet.  The chassis supports one or
two alarm cards (called AMCs), each board/switch can have a management
controller (called a PM in Motorola terminology).  This section
describes the quirks of this particular chassis and hardware.

@subsection Dual AMC support

The AMC cards operate in an active/standby configuration, except that
the standby card is not exactly a standby, it can still do some
operations and needs some management.  The active card is the only card
that has access to the IPMB bus and to the various chassis controls.

To make this work, the AMC cards have three management controllers in
OpenIPMI.  To talk to the individual cards, there are two system
managment addresses provided (channel 0xf mc 0, channel 0xf mc 1) to
talk directly to the cards.  The various sensors and controls that are
directly on the card are provided on those controllers.  The third
management controller (channel 0 mc 0x20) represents the currently
active AMC, it handles all the the chassis controls.

@subsection MXP LAN Protocol

The current versions of the MXP correctly follows one of the many
possible interpretations of the IPMI 1.5 LAN interface.  The standard
LAN interface works with it.

Older version of the MXP does not exactly follow the IPMI LAN
protocol, so a special IPMI LAN interface is required for it.  See the
@file{OpenIPMI/mxp.h} include file for a description of that
interface.  In particular, the software ID settings must be correct.
Each user of the MXP @emph{must} have a unique software ID, or chaos
will result.

Note that you can connect to an MXP using the old version protocol
handler, and if it detects a newer version of the MXP it will
automatically switch over and use the standard LAN protocol.

@subsection SEL support

In older version of the MXP, the SEL protocol also has an unusual
property.  It has a sort of ``lock'', but it does not follow the
standard IPMI protocol.  The lock also doesn't really provide any
locking and will cause problems if you have multiple management
controllers accessing the SEL.  If you never use this lock, it will
never be activated, so it doesn't matter for OpenIPMI.  However, if
you use the lock, it is activated and OpenIPMI will not be able to use
the SEL any more until the AMC is rebooted.  So @emph{never} run any
tools that might use this lock on your chassis if you want OpenIPMI to
keep working.

On older MXPs, the SELs on the AMCs have a limited size (31 entries),
are stored in a device with limited write cycles, and the firmware
does not have wear leveling.  Because of this, managing the SEL is a
little tricky.  You don't want to immediately delete events because
you will wear out the first entry in the SEL.  But it doesn't have
very many entries, so you don't want to let it fill up very full.
It's probably best to let the SEL fill up around half-way before
deleting the events.  Newer versions of the MXP do not have these
problems.

Current versions of the MXP have a very large SEL and no special
locking protocol.

@subsection Entities

In keeping with IPMI and OpenIPMI, the MXP IPMI interface provides a set
of entities to represent the various parts of the chassis.  The names of
the entity ids are all prefixed with @code{IPMI_ENTITY_ID_} for
standard entity ids or @code{MXP_ENTITY_ID_} for OEM ones in the
actual code. These entities are:

@table @samp
@item SYSTEM_CHASSIS (23)
Contains sensors and controls that relate to the entire chassis, such
as telco relays and voltage for the whole system.  The chassis is
entity instance 1.

@item MXP ALARM_CARD (144)
Things specific to the alarm card.  This is an OEM entity id because
none exist currently for an alarm card.  The alarm cards are instances
1 and 2 for the first and second alarm card.  When you create the
domain, make sure to put alarm card 1 first and alarm card 2 second in
the list of connections, otherwise things will get confused.

Note that the AMC has some sensors in the SDR with this entity id, but
they are not quite correct.  They are not per-AMC, even though the
sensors are per-AMC.

@item CONNECTIVITY_SWITCH (42)
Things related to the IP switch.  Currently, these are the same as for
the board.  The IP switches use device-relative entities on newer MXP;
older MXPs use instances 1 and 2.

@item POWER_SUPPLY (10)
Things related to the power supply.  These have instances 1, 2, and 3.

@item FAN_COOLING (29)
The fans inside the power supply.  These have instances 1, 2, and 3.

@item PROCESSING_BLADE (41)
Things related to payload boards.  These use device-relative entities
on newer MXPs, older MXPs have instances 1-18.

@end table

Newer MXPs use device-relative entity instances for all their payload
and switch boards.  They all use a fixed 60h value for either entity
instance.  OpenIPMI knows how to pick this up and use the management
controller address as part of the entity.  See the section on
device-relative entities for more details.

On older MXPs, he specific instance of each entity is identified by
the entity instance.  So the first board (the one in slot 1) is
instance 1, the second board is instance 2, etc.  Power supply 1 is
instance 1, Power supply 2 is instance 2, etc.  The instance numbers
are set up to correspond to the numbers called out in the
documentation, and are not zero based.

A section describes each entity.  All the other entities except the
fans are contained in the chassis entity, and the fans are contained
inside their power supply entity.  And remember, the entity is
@emph{the device being measured}, not the controller on which the
sensor exists.  So if the presence sensor for a power supply is on the
AMC and you message the AMC to query it, the sensor is still attached
to the power supply entity.

@subsection Sensors and Controls

The MXP has some sensors, but has a large number of sensor-like
devices that are not standard IPMI sensors.  The MXP OpenIPMI
interface makes the MXP look as if all these are IPMI sensors.
Controls are also created, in OpenIPMI these work much like sensors,
they have settable and readable values, but do not have events of any
type.

Sensors and controls may be identified by their string id and the
entity they monitor.  The string id for a sensor will be unique so it
can be separated from other sensors that may be similar.

Note that the presence sensors for entities will not appear to the
user as sensors.  The OpenIPMI system uses them to determine entity
presence and reports changes using entity presence callbacks per the
IPMI spec.

@subsubsection The Chassis
The chassis entity contains the relay controls, the system LED controls
and the chassis type and chassis id controls.

The chassis has one relay control that contains the four standard telco
relays.  The control is named ``Telco Relays'' and the elements of the
value array are:

@table @samp
@item 0
Rack relay

@item 1
Critical relay

@item 2
Major relay

@item 3
Minor relay
@end table

The chassis also has a chassis id control that contains the unique
4-byte chassis id, named ``Chassis ID'', a chassis type control
containing the 1-byte type of chassis, named ``Chassis Type'', and a
Shelf Geographic Address control names ``Shelf GA''.  These are
identifier controls.

Each AMC has a ``temp cool led'' control, but only the active AMC can
have the value set and the AMCs keep their LEDs in sync, so they are
actually part of the chassis entity.  This control gives access to the
temperature and cooling LEDs on the AMC.  These cannot be set
independently, so they are implemented as one control with two LEDs.
The first LED is the temperature LED, the second is the cooling LED.

Finally, the chassis has the system LED pair.  Unlike other LEDs these
can only be set together, because they are set in the same message.
So all LEDs appear in the same control as different LED elements.
Element 0 is the out-of-service LED, element 1 is the in-service
LED, and element 2 is the component out-of-service LED.

@subsubsection The AMC

The AMC has four voltage sensors.  The values of the sensors are
readable, but they do not generate any events.  The sensors are:

@table @samp
@item 5V
The system 5 volt sensor

@item 3.3V
The system 3.3 volt sensor

@item 2.5V
The system 2.5 volt sensor

@item 8V
The system 8 volt sensor

@item Temp
A temperature sensor

@item slot
A standard slot/connector sensor, it has the ejector latch bit (bit 6)
implemented.  This sensor generates events for changes to this bit.

@item offline
This is a standard management subsystem health sensor.  It uses the
offline bit (bit 2) to tell if the AMC is offline (inactive).  This
bit will be zero if the AMC is active, and one if the AMC is inactive.

@item presence
A standard presence sensor to tell if the AMC is installed or not.
This sensor is available even if the AMC is not installed.

@end table

It has the following controls:

@table @samp

@item OOS LED
Used to light the out-of-service LED for the board.

@item InS LED
Used to light the in-service LED for the board.

@item blue led
Used to light the blue LED for the board.

@item Last Reset Rsn
The reason for the last reset of the AMC.  Possible values are:
1 - pushbutton reset, 2 - watchdog reset, 4 - 3.3V reset, 8 - 5V reset,
16 - software reset.

@item hw version
A one-byte identifier that holds the hardware version of the AMC.

@item fw version
A one-byte identifier that holds the firmware version of the AMC.

@item fpga version
A one-byte identifier that holds the FPGA version of the AMC.

@item 


@end table

@subsubsection The Power Supplies
Each power supply has the following sensors:

@table @samp
@item presence
Used to determine whether the power supply is present.  This is a
standard IPMI presence sensor.  This sensor generates events for changes.

@item Power Supply
This is a standard power supply sensor with
two OEM extensions for the A and B feed failure events.  Offset 13 is
asserted for A feed failures, offset 14 is asserted for B feed
failures.  The A and B feeds only work on the DC power supply version,
they will always be off for an AC power supply.  Offset 0 is the
present bit, offset 1 is the power supply
failure bit, and is used to represent when the power supply fails to
generate proper output for one or more voltages.

@end table

It has the following controls:

@table @samp
@item enable
Used to turn the output of the power supply on and off.

@item OOS LED
Used to light the out-of-service LED on the power supply.

@item InS LED
Used to light the in-service LED on the power supply.

@item type
The power supply type, either: 0 - 400W AC, 1 - 400W DC, 2 - 600W AC,
3 - 600W DC, 4 - 600W Fan Sled Only, 7 - unknown.

@item revision
The power supply revision number, with two bytes.  The first byte is
the major revision, the second byte is the minor revision.  This is
not valid for 400W power supplies.

@end table

@subsubsection The Fans
Each power supply has a fan contained inside it, with the following
sensors:

@table @samp
@item presence
Used to determine if the fan is present in the power supply.  This
sensor generates events for changes.

@item speed
Used to determine if the fan is spinning fast enough.  It will
generate an event if the fan stops spinning fast enough.  The
thresholds are not readable or settable.


@item cooling
Used to determine if the fan is cooling properly.
This value is not readable.  It has two event thresholds, one
that is non-critical (the cooling alarm) and one that is
critical (the cooling fault).  This is primarily an airflow
sensor to determine if the fan is pushing any air through the
system.
@end table

It has the following controls:

@table @samp
@item OOS LED
Used to light the out-of-service LED for the fan.

@item InS LED
Used to light the in-service LED for the fan.

@item type
The power supply type, either: 0 - 400W AC, 1 - 400W DC, 2 - 600W AC,
3 - 600W DC, 4 - 600W Fan Sled Only, 7 - unknown.

@item revision
The power supply revision number, with two bytes.  The first byte is
the major revision, the second byte is the minor revision.  This is
not valid for 400W power supplies.

@end table

@subsubsection The Boards (including IP switches)
All boards have the same basic sensors and controls.  Some boards have
extra sensors.  The board sensors for all boards are:

@table @samp
@item presence
Used to determine whether the board is present.  This is a standard
IPMI presence sensor.  This sensor generates events for changes.  It
uses the Healthy bit from the board to determine it's presence.  This
sensor is available even if the board is not present.

@item slot
A standard slot/connector sensor, it currently has the ejector latch
and the power implemented.  This sensor generates events for changes
to these bits.  This sensor is available even if the board is not
present.

@item healthy
This reports the setting of the CPCI ``healthy'' line to the board.
Offset 1 is the ``enable'' bit (the only bit used), it will be set to
1 if healthy is asserted and zero if healthy is deasserted.
@end table

Boards have the following controls:

@table @samp
@item reset
Used to control the reset line on the board.

@item power
Used to control whether power is turned on for the board.

@item OOS LED
Used to light the out-of-service LED for the board.

@item InS LED
Used to light the in-service LED for the board.

@item blue led
Used to light the blue LED for the board.

@item Bd Sel
The board select line for the board may be set and read with this
control.  This control is available even if the board is not present.

@item PCI Reset
The PCI reset line for theh board may be set and read with this
control.  This control is available even if the board is not present.

@item Slot Init
A one-shot output that when set to 1 runs a slot-init cycle on the
board's slot.  (enables the I2C to the board and enables board
select).  This control is available even if the board is not present.

@item Power Config
This is the board power configuration, and consists of three items.
The first is the power mode, a zero means MXP mode (the MXP-specific
commands control the power).  A one means CPCI mode (board select
controls the poiwer).  The second byte is a boolean that disables or
enable a power-up delay.  The third byte is the power delay in tenths
of a second.

@end table

@subsubsection Sensors for the cpip5365 card

The 5365 card has some extra sensors that are on the I2C bus but not
directly available from the PM.  However, you can access them through
IPMI as raw I2C devices.  When the OEM code detects an older 5365
card, it will set up these sensors.  These will not generate events.
On newer 5365 cards with SDRs and real IPMI sensors, the real sensors
are used and the I2C sensors are not implemented.  The I2C sensors
are:

@table @samp
@item Proc Temp
The temperature of the processor.

@item Board Temp
The temperature on the board itself.

@item 1.5V
The value of 1.5V on the card.

@item 3.3V
The value of 3.3V on the card.

@item 5V
The value of 5V on the card.

@item 12V
The value of 12V on the card.

@item -12V
The value of -12V on the card.

@item Vccp
The CPU core voltage sensor (1.5V).
@end table

Note that if you use these, you @emph{cannot} use these sensors from
the 5365 card itself, or you will mess up their processing.  So don't
set up these sensors on the cards themselves if you use this software!

These sensors have their max values, min values, and nominal values
set properly (except for the temperature ones which have only max
values).

@subsubsection Sensors for the ZYNX switch
The ZYNX switch has some extra sensors that respond to normal IPMI
reading commands, but don't have a device SDRs.  The MXP OEM code adds
the sensor entries.  They do not seem to generate events.  They are:

@table @samp
@item Board Temp
The temperature on the board itself.

@item 1.8V
Voltage sensor for 1.8 volts.

@item 2.5V
Voltage sensor for 2.5 volts.

@item 3.3V
Voltage sensor for 3.3 volts.

@item 5V
Voltage sensor for 5 volts.
@end table

@subsubsection Supported Boards

OpenIPMI should support all MXP boards, current and future.  It will
be able to detect these boards and manage the MXP-specific controls
and sensors.

@subsection Known Problems

This section documents known problems with the AMC code, either with the
OpenIPMI OEM code or with the MXP firmware.

@table @samp
@item SEL (Old MXP versions only)
Currently, the SEL on the inactive AMC doesn't work with OpenIPMI.
The SEL will still provide events, but the ``Get SEL Info'' command
doesn't work.  OpenIPMI uses the ``Get SEL Info'' command to see if any
new events have been added to the SEL before a query to avoid any more
messages if the SEL hasn't been changed.  So you will get SEL errors
periodically.

@item SEL (Old MXP versions only)
Be careful not to send the MXP OEM SEL lock command to the AMC, or
OpenIPMI will no longer be able to use the SEL on that AMC (a board
removal and insertion may be required).  Some Motorola tools may do
this, so be careful.

@item Cooling sensor
The cooling sensors on the fans don't seem to work properly in the
current release of the AMC firmware.  If you block the fan input so the
fan spins but does not move any air, the MXP will generate a fan speed
event (although the fan speed sensor itself will not show anything).

@item fan presence
The fan presence events as documented in the MXP docs do not generate
events.  Thus the sensor does not work very well.  This is deprecated,
and the OpenIPMI code needs to switch over to use the power supply
presence events to generate fan presence events (since the power
supplies and fans are one unit).

@item Card voltage/temperature sensors
The card voltage and temperature sensors currently use the devices on
the I2C bus on the cards.  There are standard sensors on the boards, and
they do generate events (they are responsible for all the unknown events
when you turn off and on the power on a board).  However, they are
not set up correctly yet, and the calibration is unknown, so they are
not used.  When these sensors are ready, OpenIPMI will convert over to
using them.  It doesn't cover all the voltages, though, the ones that
are not covered will stay with the I2C bus.

The temperature sensors are not currently represented by the PM on the
boards.  When this changes, OpenIPMI will switch to using them.

@item Zynx switch ejector latches (Old Zynx switches only)
The ejector handles on the Zynx switches don't generate events.

@item Bogus entities (Old MXP versions only)
The SDRs in the AMC create some bogus entities.  The sensors on them
seem to be functional, but the entities are not standard and will
probably go away.  You can safely ignore entities ``0.0'' and
``149.26''.

@end table

@node    ATCA, , Motorola MXP, OEM Specific Information
@section ATCA

OpenIPMI has a significant start at ATCA support.  It supports the
following:

@table @samp
@item Shelf Address FRU
The shelf address FRU data will be read at startup and configuration
for every FRU will be done.

@item LEDs
LEDs should be detected and fully supported as ``Setting'' LEDs.  You
can set local control mode and all the blinking modes.  You cannot set
lamp test, though.

@item cold reset
You can do the cold reset function on the payload; it appears as a
one-shot reset control.  The other functions are not yet implemented
because there is no way to tell if they exist.

@item hot-swap
The ATCA hot-swap sensor and state machine are implemented.  There is
currently no way to get or set the auto-activation capability.  The
getting can be done fairly easily.  Setting is a problem because
changing it requires updating the FRU data, and there are a bunch of
race conditions with setting FRU data because there are no locks for
that data.

@end table

@contents

@bye
